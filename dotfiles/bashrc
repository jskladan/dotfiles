# WARN: Keep the unset at the top of the file!
# There is some PROMPT_COMMAND magic later on, and not having this would fuck-up multiple
#   `source ~/.bashrc` executions in one session
unset PROMPT_COMMAND

# Source global definitions
if [ -f /etc/bashrc ]; then
    . /etc/bashrc
fi

# Ignore /etc/hosts
export COMP_KNOWN_HOSTS_WITH_HOSTFILE=''
# Homebrew Bash-completion
[[ -r "/opt/homebrew/etc/profile.d/bash_completion.sh" ]] && . "/opt/homebrew/etc/profile.d/bash_completion.sh"

# Fix homebrew [https://github.com/orgs/Homebrew/discussions/446]
[[ -r "/opt/homebrew/bin/brew" ]] &&  eval "$(/opt/homebrew/bin/brew shellenv)"

# PyENV [https://github.com/pyenv/pyenv#set-up-your-shell-environment-for-pyenv]
if which pyenv > /dev/null 2>&1; then
    export PYENV_ROOT="$HOME/.pyenv"
    export PATH="command -v pyenv >/dev/null || $PYENV_ROOT/bin:$PATH"
    export PATH="command -v shims >/dev/null || $PYENV_ROOT/shims:${PATH}"
    eval "$(pyenv init -)"
    eval "$(pyenv virtualenv-init -)"
fi

# Git
function parse_git_branch {
  git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/(\1)/'
}

source ~/.bash_completion.d/git
source ~/.bash_completion.d/git_prompt
export GIT_PS1_SHOWDIRTYSTATE=true
export GIT_PS1_SHOWUNTRACKEDFILES=true

function pagurepr {
    remote="${2:-origin}"
    git fetch $remote pull/$1/head:pr_$1
    git checkout pr_$1
}

# Aliases
alias ls='ls -F --color' # / at the end of dirs; colorized
alias ll='ls -lah'
if which thefuck >> /dev/null; then
    eval $(thefuck --alias)
fi

if command -v nvim >/dev/null; then
    alias vim='nvim'
    export EDITOR=nvim
else
    export EDITOR=vim
fi


# Disable homebrew autoupdate on brew install
export HOMEBREW_NO_AUTO_UPDATE=1

# https://geoff.greer.fm/lscolors/
export LSCOLORS='exfxchbhcxegedabagacad'
export LS_COLORS='di=34:ln=35:so=32;47:pi=31;47:ex=32:bd=34;46:cd=34;43:su=30;41:sg=30;46:tw=30;42:ow=30;43'


# Eternal bash history.
# ---------------------
# Read eternal history to memory
ETERNAL_HISTFILE=~/.bash_history_eternal
touch $ETERNAL_HISTFILE
history -r $ETERNAL_HISTFILE

# Create new histfile for the "session"
mkdir -p ~/.bash_history_sessions
export HISTFILE=~/.bash_history_sessions/$(date '+%Y%m%d_%H%M%S').$$
echo "# HISTFILE=${HISTFILE}" > $HISTFILE

# ignore lines matching the previous history entry
#  +
# ignore lines which begin with a white space character
export HISTCONTROL=ignoreboth

# Undocumented feature which sets the size to "unlimited".
# http://stackoverflow.com/questions/9457233/unlimited-bash-history
export HISTFILESIZE=
export HISTSIZE=

# append the recenly closed session to end on EXIT signal
function historymerge {
    E1="^(ls|ll|pwd|fg|bg|exit|history|vim \.)$"
    E2="^git (fetch|pull|push|commit -am .|diff|status)$"
    E3="^(python runapp\.py|source \.bin.env.activate)$"
    grep -v -E "${E1}|${E2}|${E3}" $HISTFILE >> $ETERNAL_HISTFILE
    rm $HISTFILE
}
trap historymerge EXIT

# Force prompt to write history after every command.
# http://superuser.com/questions/20900/bash-history-loss
shopt -s histappend
PROMPT_COMMAND="history -a; $PROMPT_COMMAND"

GREY=$(tput setaf 247)
RESET=$(tput sgr0)

PS1='${GREY}[\u@\h \w]${RESET}\n${GREY}$(__git_ps1 "(%s)")${RESET}\\$ '
PS1='[\u@\h \w]\n$(__git_ps1 "(%s)")\\$ '
export PS1


export PROMPT_COMMAND_BASE="${PROMPT_COMMAND}"
# Set terminal tab name (and keep it by forcing the 'echo -ne ..') at the end of the PROMPT_COMMAND
function tabset {
    unset PROMPT_COMMAND

    # echo $HOSTNAME --> server.my.domain
    # echo ${HOSTNAME%%.*} --> server
    HOSTSTRING="${HOSTNAME%%.*}"

    case $HOSTSTRING in
        Josefs-MacBook-Pro)
            HOSTSTRING="MacBook"
            ;;
        *)
            ;;
    esac


    [[ "$EUID" -ne 0 ]] && USERSTRING="" || USERSTRING="ROOT@"

    # the complete original value of 'TABNAME'
    #TABNAME='echo -ne "\033]0;${USER}@${HOSTNAME%%.*}:${PWD/#$HOME/\~}\007"'

    TABNAME='echo -ne "\033]0;'
    if [ "$1" ]
    then
        TABNAME+="[${*}] "
    fi
    # Because I _SUUUUCK_ at bash interpolation...
    TABNAME+="${USERSTRING}${HOSTSTRING}"
    TABNAME+='\007"'

    if [[ $PROMPT_COMMAND_BASE =~ .(;|; )$ ]]
    then
        export PROMPT_COMMAND="${PROMPT_COMMAND_BASE} ${TABNAME}; "
    else
        export PROMPT_COMMAND="${PROMPT_COMMAND_BASE}; ${TABNAME}; "
    fi
}

# Set the tab name to "default"
tabset
